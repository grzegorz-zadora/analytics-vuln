{"version":3,"sources":["webpack://@segment/analytics-next/./src/lib/is-plan-event-enabled.ts","webpack://@segment/analytics-next/./src/plugins/ajs-destination/loader.ts","webpack://@segment/analytics-next/./src/plugins/ajs-destination/index.ts","webpack://@segment/analytics-next/./src/plugins/routing-middleware/index.ts","webpack://@segment/analytics-next/./src/plugins/middleware/index.ts"],"names":["isPlanEventEnabled","plan","planEvent","enabled","__default","path","window","analytics","_cdn","normalizeName","name","toLowerCase","replace","obfuscatePathName","pathName","obfuscate","btoa","undefined","loadIntegration","ctx","analyticsInstance","version","settings","Promise","obfuscatedPathName","fullPath","metric","g","performance","getEntriesByName","stats","gauge","Math","round","duration","_","recordLoadMetrics","deps","all","map","dep","integrationBuilder","Integration","user","addIntegration","integration","flushQueue","xt","queue","failedQueue","length","pop","a","result","push","failed","pushWithBackoff","options","type","middleware","_ready","_initialized","flushing","this","buffer","scheduleFlush","isLoaded","ready","onReady","resolve","load","once","onInitialize","on","increment","initialize","error","unload","_ctx","_analyticsInstance","unloadIntegration","addMiddleware","concat","fn","shouldBuffer","event","send","clz","eventType","track","ev","updateEvent","integrations","All","cancel","retry","reason","applyDestinationMiddleware","evt","JSON","parse","stringify","afterMiddleware","invoke","call","Track","page","_assumesPageview","then","Page","identify","Identify","alias","Alias","group","Group","setTimeout","todo","random","ajsDestinations","globalIntegrations","routingRules","middlewareSettings","rules","routingMiddleware","payload","next","getRulesByDestinationName","forEach","rule","matchers","transformers","i","obj","integrationOptions","Object","entries","integrationSettings","startsWith","allDisableAndNotDefined","bundlingStatus","versionSettings","componentTypes","includes","override","resolveVersion","destination","LegacyDestination","filter","destinationName","applyMiddleware","nextCalled","returnedEvent","clone","traverse","md","sourceMiddlewarePlugin","apply"],"mappings":"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","file":"ajs-destination.bundle.b3c9ba070dc87eeae516.js","sourcesContent":["import { PlanEvent, TrackPlan } from '../core/events/interfaces'\n\n/**\n * Determines whether a track event is allowed to be sent based on the\n * user's tracking plan.\n * If the user does not have a tracking plan or the event is allowed based\n * on the tracking plan configuration, returns true.\n */\nexport function isPlanEventEnabled(\n  plan: TrackPlan | undefined,\n  planEvent: PlanEvent | undefined\n): boolean {\n  // Always prioritize the event's `enabled` status\n  if (typeof planEvent?.enabled === 'boolean') {\n    return planEvent.enabled\n  }\n\n  // Assume absence of a tracking plan means events are enabled\n  return plan?.__default?.enabled ?? true\n}\n","import { Analytics } from '../../analytics'\nimport { LegacyIntegrationConfiguration } from '../../browser'\nimport { getCDN } from '../../lib/parse-cdn'\nimport { Context } from '../../core/context'\nimport { User } from '../../core/user'\nimport { loadScript, unloadScript } from '../../lib/load-script'\nimport { LegacyIntegration } from './types'\n\nconst cdn = window.analytics?._cdn ?? getCDN()\nconst path = cdn + '/next-integrations'\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase().replace('.', '').replace(/\\s+/g, '-')\n}\n\nfunction obfuscatePathName(pathName: string, obfuscate = false): string | void {\n  return obfuscate ? btoa(pathName).replace(/=/g, '') : undefined\n}\n\nfunction recordLoadMetrics(fullPath: string, ctx: Context, name: string): void {\n  try {\n    const [metric] =\n      global.window?.performance?.getEntriesByName(fullPath, 'resource') ?? []\n    // we assume everything that took under 100ms is cached\n    metric &&\n      ctx.stats.gauge('legacy_destination_time', Math.round(metric.duration), [\n        name,\n        ...(metric.duration < 100 ? ['cached'] : []),\n      ])\n  } catch (_) {\n    // not available\n  }\n}\n\nexport async function loadIntegration(\n  ctx: Context,\n  analyticsInstance: Analytics,\n  name: string,\n  version: string,\n  settings?: { [key: string]: any },\n  obfuscate?: boolean\n): Promise<LegacyIntegration> {\n  const pathName = normalizeName(name)\n  const obfuscatedPathName = obfuscatePathName(pathName, obfuscate)\n\n  const fullPath = `${path}/integrations/${\n    obfuscatedPathName ?? pathName\n  }/${version}/${obfuscatedPathName ?? pathName}.dynamic.js.gz`\n\n  try {\n    await loadScript(fullPath)\n    recordLoadMetrics(fullPath, ctx, name)\n  } catch (err) {\n    ctx.stats.gauge('legacy_destination_time', -1, [`plugin:${name}`, `failed`])\n    throw err\n  }\n\n  // @ts-ignore\n  const deps: string[] = window[`${pathName}Deps`]\n  await Promise.all(deps.map((dep) => loadScript(path + dep + '.gz')))\n\n  // @ts-ignore\n  window[`${pathName}Loader`]()\n\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let integrationBuilder = window[`${pathName}Integration`] as any\n\n  // GA and Appcues use a different interface to instantiating integrations\n  if (integrationBuilder.Integration) {\n    const analyticsStub = {\n      user: (): User => analyticsInstance.user(),\n      addIntegration: (): void => {},\n    }\n\n    integrationBuilder(analyticsStub)\n    integrationBuilder = integrationBuilder.Integration\n  }\n\n  const integration = new integrationBuilder(settings) as LegacyIntegration\n  integration.analytics = analyticsInstance\n\n  return integration\n}\n\nexport async function unloadIntegration(\n  name: string,\n  version: string,\n  obfuscate?: boolean\n): Promise<void> {\n  const pathName = normalizeName(name)\n  const obfuscatedPathName = obfuscatePathName(name, obfuscate)\n\n  const fullPath = `${path}/integrations/${\n    obfuscatedPathName ?? pathName\n  }/${version}/${obfuscatedPathName ?? pathName}.dynamic.js.gz`\n\n  return unloadScript(fullPath)\n}\n\nexport function resolveVersion(\n  settings: LegacyIntegrationConfiguration\n): string {\n  return (\n    settings.versionSettings?.override ??\n    settings.versionSettings?.version ??\n    'latest'\n  )\n}\n","import {\n  Integrations,\n  JSONObject,\n  JSONValue,\n  SegmentEvent,\n} from '@/core/events'\nimport { Alias, Facade, Group, Identify, Page, Track } from '@segment/facade'\nimport { Analytics, InitOptions } from '../../analytics'\nimport { LegacySettings } from '../../browser'\nimport { isOffline, isOnline } from '../../core/connection'\nimport { Context, ContextCancelation } from '../../core/context'\nimport { isServer } from '../../core/environment'\nimport { Plugin } from '../../core/plugin'\nimport { attempt } from '../../core/queue/delivery'\nimport { asPromise } from '../../lib/as-promise'\nimport { isPlanEventEnabled } from '../../lib/is-plan-event-enabled'\nimport { mergedOptions } from '../../lib/merged-options'\nimport { pWhile } from '../../lib/p-while'\nimport { PriorityQueue } from '../../lib/priority-queue'\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted'\nimport {\n  applyDestinationMiddleware,\n  DestinationMiddlewareFunction,\n} from '../middleware'\nimport { tsubMiddleware } from '../routing-middleware'\nimport { loadIntegration, resolveVersion, unloadIntegration } from './loader'\nimport { LegacyIntegration } from './types'\n\nconst klona = (evt: SegmentEvent): SegmentEvent =>\n  JSON.parse(JSON.stringify(evt))\n\nexport type ClassType<T> = new (...args: unknown[]) => T\n\nasync function flushQueue(\n  xt: Plugin,\n  queue: PriorityQueue<Context>\n): Promise<PriorityQueue<Context>> {\n  const failedQueue: Context[] = []\n\n  if (isOffline()) {\n    return queue\n  }\n\n  await pWhile(\n    () => queue.length > 0 && isOnline(),\n    async () => {\n      const ctx = queue.pop()\n      if (!ctx) {\n        return\n      }\n\n      const result = await attempt(ctx, xt)\n      const success = result instanceof Context\n      if (!success) {\n        failedQueue.push(ctx)\n      }\n    }\n  )\n\n  // re-add failed tasks\n  failedQueue.map((failed) => queue.pushWithBackoff(failed))\n  return queue\n}\n\nexport class LegacyDestination implements Plugin {\n  name: string\n  version: string\n  settings: Record<string, JSONValue>\n  options: InitOptions = {}\n  type: Plugin['type'] = 'destination'\n  middleware: DestinationMiddlewareFunction[] = []\n\n  private _ready = false\n  private _initialized = false\n  private onReady: Promise<unknown> | undefined\n  private onInitialize: Promise<unknown> | undefined\n\n  integration: LegacyIntegration | undefined\n\n  buffer: PriorityQueue<Context>\n  flushing = false\n\n  constructor(\n    name: string,\n    version: string,\n    settings: Record<string, JSONValue> = {},\n    options: InitOptions\n  ) {\n    this.name = name\n    this.version = version\n    this.settings = { ...settings }\n\n    // AJS-Renderer sets an extraneous `type` setting that clobbers\n    // existing type defaults. We need to remove it if it's present\n    if (this.settings['type'] && this.settings['type'] === 'browser') {\n      delete this.settings['type']\n    }\n\n    this.options = options\n    this.buffer = new PersistedPriorityQueue(4, `dest-${name}`)\n\n    this.scheduleFlush()\n  }\n\n  isLoaded(): boolean {\n    return this._ready\n  }\n\n  ready(): Promise<unknown> {\n    return this.onReady ?? Promise.resolve()\n  }\n\n  async load(ctx: Context, analyticsInstance: Analytics): Promise<void> {\n    if (this._ready || this.onReady !== undefined) {\n      return\n    }\n\n    this.integration = await loadIntegration(\n      ctx,\n      analyticsInstance,\n      this.name,\n      this.version,\n      this.settings,\n      this.options.obfuscate\n    )\n\n    this.onReady = new Promise((resolve) => {\n      const onReadyFn = (): void => {\n        this._ready = true\n        resolve(true)\n      }\n\n      this.integration!.once('ready', onReadyFn)\n    })\n\n    this.onInitialize = new Promise((resolve) => {\n      const onInit = (): void => {\n        this._initialized = true\n        resolve(true)\n      }\n\n      this.integration!.on('initialize', onInit)\n    })\n\n    try {\n      ctx.stats.increment('analytics_js.integration.invoke', 1, [\n        `method:initialize`,\n        `integration_name:${this.name}`,\n      ])\n\n      this.integration.initialize()\n    } catch (error) {\n      ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\n        `method:initialize`,\n        `integration_name:${this.name}`,\n      ])\n\n      throw error\n    }\n  }\n\n  unload(_ctx: Context, _analyticsInstance: Analytics): Promise<void> {\n    return unloadIntegration(this.name, this.version, this.options.obfuscate)\n  }\n\n  addMiddleware(...fn: DestinationMiddlewareFunction[]): void {\n    this.middleware = this.middleware.concat(...fn)\n  }\n\n  shouldBuffer(ctx: Context): boolean {\n    return (\n      // page events can't be buffered because of destinations that automatically add page views\n      ctx.event.type !== 'page' &&\n      (isOffline() || this._ready === false || this._initialized === false)\n    )\n  }\n\n  private async send<T extends Facade>(\n    ctx: Context,\n    clz: ClassType<T>,\n    eventType: 'track' | 'identify' | 'page' | 'alias' | 'group'\n  ): Promise<Context> {\n    if (this.shouldBuffer(ctx)) {\n      this.buffer.push(ctx)\n      this.scheduleFlush()\n      return ctx\n    }\n\n    const plan = this.options?.plan?.track\n    const ev = ctx.event.event\n\n    if (plan && ev && this.name !== 'Segment.io') {\n      // events are always sent to segment (legacy behavior)\n      const planEvent = plan[ev]\n      if (!isPlanEventEnabled(plan, planEvent)) {\n        ctx.updateEvent('integrations', {\n          ...ctx.event.integrations,\n          All: false,\n          'Segment.io': true,\n        })\n        ctx.cancel(\n          new ContextCancelation({\n            retry: false,\n            reason: `Event ${ev} disabled for integration ${this.name} in tracking plan`,\n            type: 'Dropped by plan',\n          })\n        )\n        return ctx\n      } else {\n        ctx.updateEvent('integrations', {\n          ...ctx.event.integrations,\n          ...planEvent?.integrations,\n        })\n      }\n\n      if (planEvent?.enabled && planEvent?.integrations[this.name] === false) {\n        ctx.cancel(\n          new ContextCancelation({\n            retry: false,\n            reason: `Event ${ev} disabled for integration ${this.name} in tracking plan`,\n            type: 'Dropped by plan',\n          })\n        )\n        return ctx\n      }\n    }\n\n    const afterMiddleware = await applyDestinationMiddleware(\n      this.name,\n      klona(ctx.event),\n      this.middleware\n    )\n\n    if (afterMiddleware === null) {\n      return ctx\n    }\n\n    const event = new clz(afterMiddleware, {})\n\n    ctx.stats.increment('analytics_js.integration.invoke', 1, [\n      `method:${eventType}`,\n      `integration_name:${this.name}`,\n    ])\n\n    try {\n      if (this.integration) {\n        await asPromise(\n          this.integration.invoke.call(this.integration, eventType, event)\n        )\n      }\n    } catch (err) {\n      ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\n        `method:${eventType}`,\n        `integration_name:${this.name}`,\n      ])\n      throw err\n    }\n\n    return ctx\n  }\n\n  async track(ctx: Context): Promise<Context> {\n    return this.send(ctx, Track as ClassType<Track>, 'track')\n  }\n\n  async page(ctx: Context): Promise<Context> {\n    if (this.integration?._assumesPageview && !this._initialized) {\n      this.integration.initialize()\n    }\n\n    return this.onInitialize!.then(() => {\n      return this.send(ctx, Page as ClassType<Page>, 'page')\n    })\n  }\n\n  async identify(ctx: Context): Promise<Context> {\n    return this.send(ctx, Identify as ClassType<Identify>, 'identify')\n  }\n\n  async alias(ctx: Context): Promise<Context> {\n    return this.send(ctx, Alias as ClassType<Alias>, 'alias')\n  }\n\n  async group(ctx: Context): Promise<Context> {\n    return this.send(ctx, Group as ClassType<Group>, 'group')\n  }\n\n  private scheduleFlush(): void {\n    if (this.flushing) {\n      return\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      this.flushing = true\n      this.buffer = await flushQueue(this, this.buffer)\n      this.flushing = false\n\n      if (this.buffer.todo > 0) {\n        this.scheduleFlush()\n      }\n    }, Math.random() * 5000)\n  }\n}\n\nexport async function ajsDestinations(\n  settings: LegacySettings,\n  globalIntegrations: Integrations = {},\n  options?: InitOptions\n): Promise<LegacyDestination[]> {\n  if (isServer()) {\n    return []\n  }\n\n  if (settings.plan) {\n    options = options ?? {}\n    options.plan = settings.plan\n  }\n\n  const routingRules = settings.middlewareSettings?.routingRules ?? []\n  const routingMiddleware = tsubMiddleware(routingRules)\n\n  // merged remote CDN settings with user provided options\n  const integrationOptions = mergedOptions(settings, options ?? {}) as Record<\n    string,\n    JSONObject\n  >\n\n  return Object.entries(settings.integrations)\n    .map(([name, integrationSettings]) => {\n      if (name.startsWith('Segment')) {\n        return\n      }\n\n      const allDisableAndNotDefined =\n        globalIntegrations.All === false &&\n        globalIntegrations[name] === undefined\n\n      if (globalIntegrations[name] === false || allDisableAndNotDefined) {\n        return\n      }\n\n      const { type, bundlingStatus, versionSettings } = integrationSettings\n      // We use `!== 'unbundled'` (versus `=== 'bundled'`) to be inclusive of\n      // destinations without a defined value for `bundlingStatus`\n      const deviceMode =\n        bundlingStatus !== 'unbundled' &&\n        (type === 'browser' ||\n          versionSettings?.componentTypes?.includes('browser'))\n\n      // checking for iterable is a quick fix we need in place to prevent\n      // errors showing Iterable as a failed destiantion. Ideally, we should\n      // fix the Iterable metadata instead, but that's a longer process.\n      if ((!deviceMode && name !== 'Segment.io') || name === 'Iterable') {\n        return\n      }\n      const version = resolveVersion(integrationSettings)\n      const destination = new LegacyDestination(\n        name,\n        version,\n        integrationOptions[name],\n        options as object\n      )\n\n      const routing = routingRules.filter(\n        (rule) => rule.destinationName === name\n      )\n      if (routing.length > 0) {\n        destination.addMiddleware(routingMiddleware)\n      }\n\n      return destination\n    })\n    .filter((xt) => xt !== undefined) as LegacyDestination[]\n}\n","import * as tsub from '@segment/tsub'\nimport { Rule } from '@segment/tsub/dist/store'\nimport { DestinationMiddlewareFunction } from '../middleware'\n\nexport type RoutingRule = Rule\n\nexport const tsubMiddleware = (\n  rules: RoutingRule[]\n): DestinationMiddlewareFunction => ({ payload, integration, next }): void => {\n  const store = new tsub.Store(rules)\n  const rulesToApply = store.getRulesByDestinationName(integration)\n\n  rulesToApply.forEach((rule) => {\n    const { matchers, transformers } = rule\n\n    for (let i = 0; i < matchers.length; i++) {\n      if (tsub.matches(payload.obj, matchers[i])) {\n        payload.obj = tsub.transform(payload.obj, transformers[i])\n\n        if (payload.obj === null) {\n          return next(null)\n        }\n      }\n    }\n  })\n\n  next(payload)\n}\n","import { Context, ContextCancelation } from '../../core/context'\nimport { SegmentEvent } from '../../core/events'\nimport { Plugin } from '../../core/plugin'\nimport { asPromise } from '../../lib/as-promise'\nimport { SegmentFacade, toFacade } from '../../lib/to-facade'\n\nexport interface MiddlewareParams {\n  payload: SegmentFacade\n\n  integrations?: SegmentEvent['integrations']\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport interface DestinationMiddlewareParams {\n  payload: SegmentFacade\n  integration: string\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport type MiddlewareFunction = (middleware: MiddlewareParams) => void\nexport type DestinationMiddlewareFunction = (\n  middleware: DestinationMiddlewareParams\n) => void\n\nexport async function applyDestinationMiddleware(\n  destination: string,\n  evt: SegmentEvent,\n  middleware: DestinationMiddlewareFunction[]\n): Promise<SegmentEvent | null> {\n  async function applyMiddleware(\n    event: SegmentEvent,\n    fn: DestinationMiddlewareFunction\n  ): Promise<SegmentEvent | null> {\n    let nextCalled = false\n    let returnedEvent: SegmentEvent | null = null\n\n    await asPromise(\n      fn({\n        payload: toFacade(event, {\n          clone: true,\n          traverse: false,\n        }),\n        integration: destination,\n        next(evt) {\n          nextCalled = true\n\n          if (evt === null) {\n            returnedEvent = null\n          }\n\n          if (evt) {\n            returnedEvent = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled && returnedEvent !== null) {\n      returnedEvent = returnedEvent as SegmentEvent\n      returnedEvent.integrations = {\n        ...event.integrations,\n        [destination]: false,\n      }\n    }\n\n    return returnedEvent\n  }\n\n  for (const md of middleware) {\n    const result = await applyMiddleware(evt, md)\n    if (result === null) {\n      return null\n    }\n    evt = result\n  }\n\n  return evt\n}\n\nexport function sourceMiddlewarePlugin(\n  fn: MiddlewareFunction,\n  integrations: SegmentEvent['integrations']\n): Plugin {\n  async function apply(ctx: Context): Promise<Context> {\n    let nextCalled = false\n\n    await asPromise(\n      fn({\n        payload: toFacade(ctx.event, {\n          clone: true,\n          traverse: false,\n        }),\n        integrations: integrations ?? {},\n        next(evt) {\n          nextCalled = true\n          if (evt) {\n            ctx.event = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled) {\n      throw new ContextCancelation({\n        retry: false,\n        type: 'middleware_cancellation',\n        reason: 'Middleware `next` function skipped',\n      })\n    }\n\n    return ctx\n  }\n\n  return {\n    name: `Source Middleware ${fn.name}`,\n    type: 'before',\n    version: '0.1.0',\n\n    isLoaded: (): boolean => true,\n    load: (ctx): Promise<Context> => Promise.resolve(ctx),\n\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply,\n  }\n}\n"],"sourceRoot":""}